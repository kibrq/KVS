\section*{Анализ}

\subsection*{Предположения}
\begin{enumerate}
	\item Размер значения и ключа, постоянные.
	
	\item Размер блока не слишком большой (4kB).
	
	\item Ключ и значение оффсета помещаются в блок не менее 100 раз
	
	\item Значение помещается в один блок и может быть считано и записано одной элементарной операцией чтения/записи
	
\end{enumerate}
\newpage
\subsection*{Обозначения}

(const) $N$ -- количество различных ключей, на хранение которых рассчитано хранилище. (100000)

(const) $S_v$ -- размер хранимых значений (в байтах). (2KB)

(const) $S_k$ -- размер хранимых ключей (в байтах). (128b)

(const) $F$ -- объем памяти на используемом флеш-накопителе (в гигабайтах). (128GB)

(const) $E$ -- максимальное количество циклов перезаписи каждой ячейки на используемом флеш-накопителе. (10 000)

(const) $U_w$ -- скорость, с которой поступают запросы на запись. (5 МБ/с)

(variable) $L$ -- максимальное количество записей, единовременно лежащее в Log

(const) $S_h$ -- размер хэша, распределяющего ключи по блокам (в байтах) ($\sim\lceil\frac{\log_2 \frac{N}{b}}{8}\rceil = 2\ \operatorname{or}\ 3$)

(const) $S_o$ -- размер указателя на позицию в файле (в байтах) ($ \lceil\log_2N\rceil = \frac{17}{8}$)

(const) $b$ -- количество пар ключ-указатель, помещающееся в один блок диска ($\lceil\frac{block\ size}{S_k + S_o}\rceil = 225$)

(variable) $k$ -- количество операций между сбрасыванием лога на диск

\subsection*{Метрики}

\large$WA = 1 + \frac{1}{L}\cdot\frac{N}{b} + \frac{1}{k}$\normalsize

$1$ -- запись файла

$\frac{N}{b}$ -- размер индекса, который перезаписывается каждые $L$ записей

$\frac{1}{k}$ -- траты на сброс лога на диск (с учётом того, что он помещается в один блок памяти)

\large$RA = \frac{L + 2(N-L)}{N} = 2 - \frac{L}{N}$\normalsize

Вероятность найти сразу в логе -- $\frac{L}{N}$, тогда сразу считаем файл с диска, иначе 2 чтения (страница индекса и сам файл)

\large$SA = \frac{N\cdot S_v + \frac{N}{b}\cdot (block\ size)}{N(S_v + S_k)} = \frac{S_v + \frac{block\ size}{b}}{S_v + S_k}$\normalsize

Сами файлы и индекс

\large$MO = \frac{\frac{N}{8} + \frac{N\cdot S_h}{b} + L(S_k + S_o)}{N} = \frac{1}{8} + \frac{S_h}{b} + \frac{L}{N}(S_k + S_o)$\normalsize

Битмаска свободных мест, хэши для промежутков в индексе и лог, соответственно

\large$T = \frac{F\cdot E}{WA\cdot U_w}$\normalsize

\subsection*{Компромиссы}

Выбора тут не очень много, единственная переменная -- размер лога. Её влияние:

$WA\downarrow\downarrow\downarrow\ \ RA \downarrow\ \ MO \uparrow\uparrow\uparrow$

Есть ещё условно переменная величина -- частота сброса лога на диск, но она влияет только на $WA$ и, допустим, заказчик сказал, что не хочет терять больше 10 записей, а значит $k = 10$

\subsection*{Оптимум}

Подставим конкретные значения из условия:

\large$WA = 1 + \frac{444}{L} + \frac{1}{10} = 1.1 + \frac{444}{L}$\normalsize

\large$RA = \frac{L + 2(10^5-L)}{10^5} = 2 - \frac{L}{10^5}$\normalsize

\large$SA = \frac{2048 + \frac{4096}{225}}{2064} = 1.001$\normalsize

\large$MO = \frac{1}{8} + \frac{S_h}{b} + \frac{L}{N}(S_k + S_o) = 0.134 + (18+\frac{1}{8})\frac{L}{N}$\normalsize

Не хочется делать $L$ слишком большим, по нему бегать всё-таки при любом запросе, но для $WA$ его желательно увеличивать. Мне кажется, что значение $2000 (=0.02N)$ вполне подходит под баланс

Итого:

\large$WA = 1.32$\normalsize

\large$RA = 1.98$\normalsize

\large$SA = 1.001$\normalsize

\large$MO = 0.5$\normalsize

\large$T = 6.3\ $\normalsize года

\section*{Дополнение}

Так как у нас MO получилось сильно ниже, чем разрешено по условию задачи, то оставшейся памяти хватит на добавление фильтра Блюма перед вторым уровнем. Поэтому, если хранилище получилось слишком простым, то мы готовы добавить его.