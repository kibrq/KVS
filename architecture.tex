\section*{Архитектура}
  \subsection*{Общее описание}
      Модель состоит из двух уровней. 
      \begin{itemize} 
      \item 
        На первом уровне находится Log, состоящий из двух векторов. В первом векторе находятся ключи, во втором оффсеты. Если просят удалить запись, то хранится специально выбранный оффсет (условно -1).
      \item
        Второй уровень состоит из разреженной SSTable и хэш-функции, действущей из исходных ключей в битовые строки длины $S_h$.
        В оперативной памяти хранятся отсортированные $S_h$-битные строки, а на диске хранятся пары ключ-оффсет выровненные по страницам, 
        то есть чтобы на одной странице было целое число пар. Поддерживаем инвариант, что в $k$ странице лежат пары ключ-оффсет, хэш ключа которых лежит между $k$-ым и $k-1$-ым хэшами на первом уровне. 
        Тогда по хэшу ключа можно понять на какой странице его можно искать. Также пары внутри страниц сортируем по ключу.
      \end{itemize}

      Назовем ячейкой - последовательность из $S_v$ байт в файле со значениями. В оперативной памяти лежит битмаска свободных ячеек. 
      Так как размер значений фиксированный, то достаточно хранить оффсет, не полный, а деленный на $S_v$.

    \subsection*{Описание выполнения запросов}
      \subsubsection*{Поиск}
        Вначале смотрим, как обычно, Log. Если там ничего нет, то идем на второй уровень. 
        Считаем хэш ключа и бин-поиском ищем в первом уровне SSTable, его место. 
        Найдя интервал между хэшами, в который он попадает, берем соответсвующую найденному интервалу страницу с парами ключ-оффсет и смотрим есть ли там такой ключ. 
        Если нашли такой ключ, то идем в файл со значениями и читаем по оффсету.

      \subsubsection*{Добавление}
        Находим за не хуже, чем $\frac{N}{w}$ свободную ячейку в битмаске, записываем значение в эту ячейку и кладем в Log пару ключ-оффсет.

      \subsubsection*{Удаление}
        Делаем поиск. По найденному оффсету освобождаем ячейку в битмаскe, не забывая делать в Log запись.

      \subsection*{Слияние}
        Когда Log переполняется, мы полностью переписываем второй уровень структуры. То есть собираем все живые ключи, считаем от них хэши, сортируем по хэшам. В этом порядке разбиваем на блоки (Если несколько равных хэшей попали в разные блоки, то перекидавыем из предыдущего в последующий, слишком сильно уменьшиться от этого блок не должен). Находим между каждой последовательной парой блоков некоторое значение (больше всех в предыдущем, не больше всех в последующем). Эти значения остаются в оперативной памяти как разреженная версия SSTable. Теперь разбитые на блоки ключи-офсеты сортируем между собой по ключу.

      \subsection*{Восстановление}
        Вся нужная информация содержится на втором уровне SSTable. Пробегаемся по ключам-оффсетам. По ним можно восстановить первый уровень таблицы, посчитав хэши и посортировав. Также по оффсетам можно 
        восстановить битмаску. Остается раз в $k$ операций бэкапить Log. Бэкапить безхитростно - просто скидывать на диск.
