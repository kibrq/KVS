\section*{Архитектура}
  \subsection*{Общее описание}
      Модель состоит из двух уровней. 
      \begin{itemize} 
      \item 
        На первом уровне находится Log, состоящий из двух векторов. В первом векторе находятся ключи, во втором оффсеты. Если просят удалить запись, то хранится специально выбранный оффсет (условно -1).
      \item
        Второй уровень состоит из разреженной SSTable и хэш-функции, действущей из исходных ключей в битовые строки длины $m$.
        В оперативной памяти хранятся отсортированные $m$-битные строки, а на диске хранятся пары ключ-оффсет выровненные по стрницам, 
        то есть чтобы на одной странице было целое число пар. Поддерживаем инвариант, что в $k$ странице лежат пары ключ-значение, хэш ключа которых есть $k$-ый хэш на первом уровне. 
        Тогда по хэшу ключа можно понять на какой странице его можно искать.
      \end{itemize}

      Назовем ячейкой - последовательность из $S_v$ байт на диске. В оперативной памяти лежит битмаска свободных ячеек. 
      Так как размер значений фиксированный, то достаточно хранить оффсет, не полный, а деленный на $S_v$.

    \subsection*{Описание выполнения запросов}
      \subsubsection*{Поиск}
        Вначале смотрим, как обычно, Log. Если там ничего нет, то идем на второй уровень. 
        Считаем хэш ключа и бин-поиском ищем в первом уровне SSTable, его место. Если такого хэша нет, значит и записи такой нет.
        Если есть, то берем соответсвующую найденному номеру страницу с парами ключ-оффсет и смотрим есть ли там такой ключ. 
        Если нашли такой ключ, то идем на диск и читаем по оффсету.

      \subsubsection*{Добавление}
        Находим за не хуже, чем $\frac{N}{w}$ свободную ячейку в битмаске и кладем в Log запись.

      \subsubsection*{Удаление}
        Делаем поиск и по полученному оффсету освобождаем ячейку в битмаскe, не забывая делать в Log запись.

      \subsection*{Слияние}
        Когда Log переполняется, мы полностью переписываем второй уровень структуры. То есть собираем все живые ключи, считаем от них хэши, сортируем и тому подобное.

      \subsection*{Восстановление}
        Вся нужная информация содержится на втором уровне SSTable. Пробегаемся по ключам-оффсетам. По ним можно восстановить первый уровень таблицы, посчитав хэши и посортировав. Также по оффсетам можно 
        восстановить битмаску. Остается раз в $k$ операций бэкапить Log. Бэкапить безхитростно - просто скидывать на диск.
