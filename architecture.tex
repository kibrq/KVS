\section*{Архитектура}
  \subsection*{Общее описание}
      Модель состоит из двух уровней. 
      \begin{itemize} 
      \item 
        На первом уровне находится Log, состоящий из двух векторов. В первом векторе находятся ключи, во втором оффсеты. Если просят удалить запись, то сохраняется специально выбранный оффсет (условно -1).
      \item
        * UPDATED: Между первым и вторым уровнем есть фильтр Блума, который лежит в оперативной памяти *
      \item
        Второй уровень состоит из разреженной SSTable и хэш-функции, действущей из исходных ключей в битовые строки длины $S_h$.
        В оперативной памяти хранятся отсортированные $S_h$-битные строки, а на диске хранятся пары ключ-оффсет выровненные по страницам, 
        то есть чтобы на одной странице было целое число пар. Поддерживаем инвариант, что в $k$-ой странице лежат пары ключ-оффсет, хэш ключа которых лежит между $k$-ым и $k-1$-ым хэшами на первом уровне. 
        Тогда по хэшу ключа можно понять на какой странице его можно искать. Также пары внутри страниц сортируем по ключу.
      \end{itemize}

      Назовем ячейкой - последовательность из $S_v$ байт в файле со значениями. В оперативной памяти лежит битмаска свободных ячеек. 
      Так как размер значений фиксированный, то достаточно хранить оффсет, не полный, а деленный на $S_v$.

    \subsection*{Описание выполнения запросов}
      \subsubsection*{Поиск}
        * UPDATED: Теперь перед тем, как лезть в таблицу, смотрим на фильтр Блума * \par
        Вначале смотрим, как обычно, Log. Если там ничего нет, то идем на второй уровень. 
        Считаем хэш ключа и бин-поиском ищем в первом уровне SSTable, его место. 
        Найдя интервал между хэшами, в который он попадает, берем соответсвующую найденному интервалу страницу с парами ключ-оффсет и смотрим есть ли там такой ключ. 
        Если нашли такой ключ, то идем в файл со значениями и читаем по оффсету.

      \subsubsection*{Добавление}
        Находим за не хуже, чем $\frac{N}{w}$ свободную ячейку в битмаске, записываем значение в эту ячейку и кладем в Log пару ключ-оффсет.

      \subsubsection*{Удаление}
        Делаем поиск. По найденному оффсету освобождаем ячейку в битмаскe, не забывая делать в Log запись.

      \subsection*{Слияние}
        * UPDATED:
        Когда Log переполняется, мы берем из него записи, разрешаем конфликты и сортируем ключи-оффсеты по хэшам ключей. Затем, генерируем итератор записей из индекса, который при необходимости 
        загружает в оперативную память новый блок с ключами, посортив их по хэшу ключей, также чистим фильтр и таблицу первого уровня. 
        Мерждим страничный итератор и из лога, как два итератора, элементы которых отсортированы. 
        Когда смерджили необходимое количество записей (наибольшее, помещающееся в блок), выгружаем это на диск в свободное место и добавляем ключ в фильтр и интервал в таблицу на первом уровне. 
        
        Стоит отметить, что в памяти при такой работе будет находиться не более одного блока. 
        *
      \subsection*{Восстановление}
        * UPDATED: Также по второму уровню таблицу можно восстановить фильтр Блума *

        Вся нужная информация содержится на втором уровне SSTable. Пробегаемся по ключам-оффсетам. По ним можно восстановить первый уровень таблицы, посчитав хэши и посортировав. Также по оффсетам можно 
        восстановить битмаску. Остается раз в $k$ операций бэкапить Log. Бэкапить безхитростно - просто скидывать на диск.

